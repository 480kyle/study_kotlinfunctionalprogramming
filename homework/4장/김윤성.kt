/*
 * This Kotlin source file was generated by the Gradle 'playground.init' task.
 */
package playground

import arrow.core.Either
import arrow.core.None
import arrow.core.Option
import arrow.core.Some
import kotlin.math.pow

fun <A, B> Option<A>.map(block: (A) -> B) = when (this) {
    is Some -> Some(block(value))
    is None -> None
}

fun <A> Option<A>.getOrElse(default: () -> A): A = when (this) {
    is None -> default()
    is Some -> this.value
}


fun <A, B> Option<A>.flatMap(block: (A) -> Option<B>): Option<B> = map(block).getOrElse { None }

fun <A> Option<A>.orElse(block: () -> Option<A>): Option<A> = map {
    Some(it)
}.getOrElse { block() }

fun <A> Option<A>.filter(block: (A) -> Boolean): Option<A> =
    when (this) {
        is Some -> if (block(value)) this else None
        None -> None
    }

fun mean(xs: List<Double>): Option<Double> =
    if (xs.isEmpty()) None
    else Some(xs.sum() / xs.size)

fun variance(xs: List<Double>): Option<Double> =
    mean(xs).flatMap { mean ->
        val squaredDifferences = xs.map { x -> (x - mean).pow(2) }
        mean(squaredDifferences)
    }


fun <A, B, C> map(oa: Option<A>, ob: Option<B>, block: (A, B) -> C): Option<C> =
    oa.flatMap { a ->
        ob.map { b ->
            block(a, b)
        }
    }

fun <A> sequence(xs: List<Option<A>>): Option<List<A>> =
    xs.foldRight(Some(emptyList())) { oa, acc ->
        when (oa) {
            is Some -> acc.map { list -> listOf(oa.value) + list }
            is None -> None
        }
    }

fun <A, B> traverse(
    xa: List<A>,
    block: (A) -> Option<B>
): Option<List<B>> =
    xa.foldRight(Some(emptyList())) { a, acc ->
        acc.flatMap { l ->
            block(a).map { b ->
                listOf(b) + l
            }
        }
    }

fun <E, A, B> Either<E, A>.map(f: (A) -> B): Either<E, B> =
    when (this) {
        is Either.Right -> Either.Right(f(this.value))
        is Either.Left -> this
    }

fun <E, A, B> Either<E, A>.flatMap(f: (A) -> Either<E, B>): Either<E, B> =
    when (this) {
        is Either.Right -> f(this.value)
        is Either.Left -> this
    }

fun <E, A> Either<E, A>.orElse(f: () -> Either<E, A>): Either<E, A> =
    when (this) {
        is Either.Right -> this
        is Either.Left -> f()
    }

fun <E, A, B, C> map2(
    ae: Either<E, A>,
    be: Either<E, B>,
    f: (A, B) -> C
): Either<E, C> =
    ae.flatMap { a ->
        be.map { b ->
            f(a, b)
        }
    }


fun <E, A, B> traverse2(
    xs: List<A>,
    block: (A) -> Either<E, B>
): Either<E, List<B>> =
    xs.fold(Either.Right(emptyList())) { acc, a ->
        acc.flatMap { list ->
            block(a).map { b ->
                list + b
            }
        }
    }

fun <E, A> sequence2(es: List<Either<E, A>>): Either<E, List<A>> = traverse2(es) { it }


