/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package playground

import playground.FOption.Companion.getOrElse
import playground.FOption.None.map


object Nil : List<Nothing>() {
    override fun toString(): String = "Nil"
}

//
data class Cons<out A>(val head: A, val tail: List<A>) : List<A>() {
    override fun toString(): String {
        return "{ head: $head, tail: $tail }"
    }
}

sealed class List<out A> {
    companion object {
        fun <A> of(vararg aa: A): List<A> {
            val tail = aa.sliceArray(1 until aa.size)
            return if (aa.isEmpty()) Nil else Cons(aa[0], of(*tail))
        }

        inline operator fun <ITEM : Any> invoke(vararg items: ITEM): List<ITEM> = items.foldRight(invoke(), ::Cons)
        inline operator fun <ITEM : Any> invoke(): List<ITEM> = Nil
    }
}

sealed class FOption<out VALUE : Any> {
    object None : FOption<Nothing>()
    data class Some<out VALUE : Any> @PublishedApi internal constructor(val value: VALUE) : FOption<VALUE>()
    companion object {
        inline operator fun <VALUE : Any> invoke(): FOption<VALUE> = None
        inline operator fun <VALUE : Any> invoke(value: VALUE): FOption<VALUE> = Some(value)
        inline fun <VALUE : Any> catches(throwBlock: () -> VALUE): FOption<VALUE> = try {
            FOption(throwBlock())
        } catch (e: Throwable) {
            None
        }

        inline operator fun <VALUE : Any> invoke(block: Unwrap.() -> VALUE): FOption<VALUE> = try {
            FOption(Unwrap.block())
        } catch (e: Throwable) {
            None
        }

        inline fun <VALUE : Any> FOption<VALUE>.getOrElse(block: () -> VALUE): VALUE = when (this) {
            is None -> block()
            is Some -> value
        }

    }

    object Unwrap {
        inline operator fun <VALUE : Any> FOption<VALUE>.component1(): VALUE = when (this) {
            is None -> throw Throwable()
            is Some -> value
        }
    }

    inline fun <VALUE : Any, OTHER : Any> FOption<VALUE>.map(block: (VALUE) -> OTHER): FOption<OTHER> = when (this) {
        is FOption.None -> this
        is FOption.Some -> FOption(block(value))
    }

}


sealed class Stream<out A> {
    data class ConsStream<out A>(
        val head: () -> A,
        val tail: () -> Stream<A>
    ) : Stream<A>()

    object EmptyStream : Stream<Nothing>()
    companion object {
        fun <A> cons(hd: () -> A, tl: () -> Stream<A>): Stream<A> {
            val head: A by lazy(hd)
            val tail: Stream<A> by lazy(tl)
            return ConsStream({ head }, { tail })
        }

        fun <A> empty(): Stream<A> = EmptyStream

        fun <A> of(vararg xs: A): Stream<A> =
            if (xs.isEmpty()) empty() else cons({ xs[0] }, { of(*xs.sliceArray(1 until xs.size)) })
    }

    tailrec fun <ITEM : Any, ACC : Any> List<ITEM>.fold(acc: ACC, block: (ACC, ITEM) -> ACC): ACC = when (this) {
        is Cons -> tail.fold(block(acc, head), block)
        is Nil -> acc
    }

    inline fun <ITEM : Any> List<ITEM>.reverse(): List<ITEM> = fold(List()) { acc, it -> Cons(it, acc) }

    tailrec fun <A, B> Stream<A>.foldLeft(acc: B, fcn: (B, A) -> B): B = when (this) {
        is ConsStream -> tail().foldLeft(fcn(acc, head()), fcn)
        is EmptyStream -> acc
    }

    fun <A> Stream<A>.reverse() = foldLeft(Stream.of<A>()) { acc, a -> ConsStream({ a }, { acc }) }

    fun <A> Stream<A>.toList(): List<A> =
        when (this) {
            is ConsStream -> Cons(head(), tail().toList())
            is EmptyStream -> Nil
        }

    fun <ITEM : Any> Stream<ITEM>.take(n: Int): Stream<ITEM> {
        fun _take(xs: Stream<ITEM>, n: Int): Stream<ITEM> = when (xs) {
            is EmptyStream -> empty()
            is ConsStream ->
                if (n == 0) empty()
                else cons(xs.head) { _take(xs.tail(), n - 1) }
        }
        return _take(this, n)
    }

    fun <ITEM : Any> Stream<ITEM>.drop(n: Int): Stream<ITEM> {
        tailrec fun _drop(xs: Stream<ITEM>, n: Int): Stream<ITEM> = when (xs) {
            is EmptyStream -> empty()
            is ConsStream ->
                if (n == 0) xs
                else _drop(xs.tail(), n - 1)
        }
        return _drop(this, n)
    }

    fun <ITEM : Any> Stream<ITEM>.takeWhile(fcn: (ITEM) -> Boolean): Stream<ITEM> = when (this) {
        is EmptyStream -> empty()
        is ConsStream ->
            if (fcn(this.head()))
                cons(head) { this.tail().takeWhile(fcn) }
            else empty()
    }

    fun <A : Any> Stream<A>.exists(fcn: (A) -> Boolean): Boolean = when (this) {
        is ConsStream -> fcn(head()) || tail().exists(fcn)
        else -> false
    }


    fun <A : Any, B : Any> Stream<A>.foldRight(
        acc: () -> B,
        fcn: (A, () -> B) -> B
    ): B = when (this) {
        is ConsStream -> fcn(head()) {
            tail().foldRight(acc, fcn)
        }

        is EmptyStream -> acc()
    }

    fun <A : Any, B : Any> Stream<A>.map(fcn: (A) -> B): Stream<B> =
        foldRight({ empty<B>() }, { head, tail -> cons({ fcn(head) }, tail) })

    fun <A : Any> Stream<A>.filter(fcn: (A) -> Boolean): Stream<A> = foldRight(
        { empty() },
        { head, tail -> if (fcn(head)) cons({ head }, tail) else tail() }
    )

    fun <A : Any> Stream<A>.append(stream: () -> Stream<A>): Stream<A> =
        foldRight(stream) { head, tail -> cons({ head }, tail) }

    fun <A : Any, B : Any> Stream<A>.flatMap(f: (A) -> Stream<B>): Stream<B> = foldRight(
        { empty<B>() },
        { head, tail -> f(head).append(tail) }
    )

    fun <A : Any> constant(a: A): Stream<A> = Stream.cons({ a }, { constant(a) })
    fun from(n: Int): Stream<Int> = cons({ n }, { from(n + 1) })
    fun fibs(): Stream<Int> {
        fun _fibs(curr: Int, next: Int): Stream<Int> = cons({ curr }, { _fibs(next, curr + next) })
        return _fibs(0, 1)
    }

    fun <A : Any, S : Any> unfold(acc: S, fcn: (S) -> FOption<Pair<A, S>>): Stream<A> = fcn(acc).map { pair ->
        cons({ pair.first }, { unfold(pair.second, fcn) })
    }.getOrElse {
        empty()
    }

    fun fibs2(): Stream<Int> = unfold(0 to 1) { (curr, next) ->
        FOption.Some(curr to (next to (curr + next)))
    }

    fun from2(n: Int): Stream<Int> = unfold(n) { a -> FOption.Some(a to (a + 1)) }

    fun <A : Any> constant2(n: A): Stream<A> = unfold(n) { a -> FOption.Some(a to a) }

    fun ones(): Stream<Int> = unfold(1) { FOption.Some(1 to 1) }

    fun <A : Any, B : Any> Stream<A>.map3(f: (A) -> B): Stream<B> = unfold(this) { s: Stream<A> ->
        when (s) {
            is ConsStream -> FOption.Some(f(s.head()) to s.tail())
            else -> FOption.None
        }
    }

    fun <A : Any> Stream<A>.take3(n: Int): Stream<A> = unfold(this) { s: Stream<A> ->
        when (s) {
            is ConsStream ->
                if (n > 0)
                    FOption.Some(s.head() to s.tail().take(n - 1))
                else FOption.None

            else -> FOption.None
        }
    }

    fun <A : Any> Stream<A>.takeWhile3(predicate: (A) -> Boolean): Stream<A> = unfold(this) { s: Stream<A> ->
        when (s) {
            is ConsStream ->
                if (predicate(s.head()))
                    FOption.Some(s.head() to s.tail())
                else FOption.None

            else -> FOption.None
        }
    }

    fun <A : Any, B : Any, C : Any> Stream<A>.zipWith13(
        other: Stream<B>,
        fcn: (A, B) -> C
    ): Stream<C> = unfold(this to other) { (one: Stream<A>, another: Stream<B>) ->
        when (one) {
            is ConsStream ->
                when (another) {
                    is ConsStream ->
                        FOption.Some(
                            Pair(
                                fcn(one.head(), another.head()),
                                one.tail() to another.tail()
                            )
                        )

                    else -> FOption.None
                }

            else -> FOption.None
        }
    }

    fun <A : Any, B : Any> Stream<A>.zipAll(
        that: Stream<B>
    ): Stream<Pair<FOption<A>, FOption<B>>> = unfold(this to that) { (ths, tht) ->
        when (ths) {
            is ConsStream -> when (tht) {
                is ConsStream -> FOption.Some(
                    Pair(
                        FOption.Some(ths.head()) to FOption.Some(tht.head()),
                        ths.tail() to tht.tail()
                    )
                )

                else -> FOption.Some(
                    Pair(
                        FOption.Some(ths.head()) to FOption.None,
                        ths.tail() to empty()
                    )
                )
            }

            else -> when (tht) {
                is ConsStream -> FOption.Some(
                    Pair(
                        FOption.None to FOption.Some(tht.head()),
                        empty<A>() to tht.tail()
                    )
                )
                else -> FOption.None
            }
        }
    }
}
